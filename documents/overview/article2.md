# Promise是如何工作的

> 大部分的JavaScript实现都是单线程的，并且考虑到语言的语义，人们倾向于使用 callbacks （回调函数）来管理并行的过程。在JavaScript中，虽然使用 Continuation-Passing Style(后继传递格式) 并没有什么明显的过错， 但实际上，这样做会非常容易让代码变得难以阅读和更加程序化（比起它本应有的样子）。

### 什么是Promise

**Promise是最终结果的表示形式。**

当我们要给函数提供了输入，为了让我们获得想要的输出，我们需要一直坐等直到函数完成它的工作。 但是理想情况是：我们想要在这段时间内尽量多做点别的事情，而不光是坐着等待。

为了解决这种问题，promise被提了出来，我们会立刻取得某种表示形式来代表这个值，而不需要一直等到最终结果出来。

### 执行顺序

按顺序执行的代价是非常高的。很容易阻塞。

JavaScript的内在语义是同步顺序的。但我们可以创造一种分离机制，来描述表达式之间的依赖，并且帮助我们解决这些依赖关系，然后根据这些规则执行程序。其中一种实现方法，就是通过在promise之上引入依赖的概念。

### Promise

这种promises的新机制由两个主要部分构成: 一是可以作为值的表现形式（representations），并把值放入这种表示形式中；二是创建表达式（expressions）和值（values）之间的依赖关系（dependencies），创建一个新的promise，就是为了取得表达式的结果。

我们的promise代表着我们还没计算出来的值。这个表示形式是不透明的: 我们看不见值，也不能直接和值相互作用。此外，在JavaScript的promise中，我们也不能从表示形式中取出值。一旦你把一些东西放进一个JavaScript promise，你 不能 从promise里面直接取出来。

### ECMAScript Promise

在标准promise中，主要的方法是 new Promise(...) 引入一个promise对象，然后用 .then(...) 变换。

new Promise(f) 构造一个新的promise对象，它通过计算，最终带着某个特定值将状态变为成功或失败。成功或失败的行为，按照预期传递到函数 f， f 是带有两个参数的函数对象。第一个参数用在处理执行成功的场景，第二个参数则用在处理执行失败的场景，因此：

Promise.then(f, g) 是一个操作，它在一个有空洞的表达式和一个值之间创建依赖关系，f 和 g 都是可选参数，如果它们都没被提供，promise会把值在那个状态中传播。

传给 .then 的函数参数可以是一个promise，也可以是一个常规的值，在这种情况下， .then 操作会自动帮你把值放入到promise当中。.then会把值转换成一个包含该值的promise。本质上说，.then 会按需把常规值转换为promise。

并行依赖多个值可以通过 Promise.all 操作来处理。

失败和成功的传播通过 .then 操作自身来处理，另外还提供了.catch 操作，作为一种简洁的、无需定义成功分支的 .then 调用。

如果一个异常同步地发生在 .then 方法计算依赖关系的过程中，那么异常会被捕捉到，并具体化为一个被拒绝的Promise。本质上，这意味着所有的在 .then 中的附加在promise的值之上的计算，都好像被包裹在 try/catch 代码块之中。

### 适用范围

虽然promise作为原生并发可以很好地工作，但promise既不像Continuation-Passing Style那样普遍，也不是所有用例的最佳解决方案。Promise是值的占位符，最终会被计算出来，因此它只能在上下文当中有意义，因为你可以使用那些值自身。

以下是一些应该完全避免使用promise的例子：

* **通知计算某个特定值的结果**。 Promise被用在和值本身一样的上下文中，所以就像我们不能知道计算某个特定的字符串的进度一样，给定字符串本身，我们不能用promise来做这个。因为这个，如果你有兴趣知道一个文件的下载进度，你会想要一个分离的东西，比如说事件。

* **一段时间内需要产生多个值**。 Promises只能代表单个最终值。对于一段时间内要产生多个值的情况 (等价于异步迭代器)，你可能需要像流(Streams)，Observables，或者 CSP Channels 这样的东西。

* **表示动作**。 这也意味着不能按顺序执行promise，因为一旦得到一个promise，就马上开始计算它的值了。对于动作可以使用 CPS，Continuation monad，或者像 C♯ 那样的 Task (co)monad。